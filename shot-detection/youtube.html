<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel=stylesheet href="main.css" type="text/css" />
    <script
        src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"
        type="text/javascript"></script>
    <script src="histogram.js" type="text/javascript"></script>
    <script src="stat.js" type="text/javascript"></script>
  </head>
  <body>
    <div class="embedded">
      <div>
        <form onsubmit="return false;">
          <input id="video_id" value="Hu-YsZNpkZs" />
          <button type="submit" id="start">OK</button>
          <small>
            <input id="debug" type="checkbox"/>
            <label for="debug"> Debug</label>
            <span id="debug_options">
              <input id="different" type="checkbox" checked />
              <label for="different"> Show Most Different Tiles</label>
              <input id="similar" type="checkbox" checked />
              <label for="similar"> Show Most Similar Tiles</label>
            </span>
          </small>
        </form>
      </div>
    
      <div class="video" id="video"></div> 
     
      <div>  
        <div>
          <div class="label"><small id="rows_min">1</small></div>
          <input id="rows" type="range" min="1" max="20" step="1"/>
          <div class="label"><small id="rows_max">20</small></div>
          <input class="options" id="rows_value"/> # Rows
          <br/>
        
          <div class="label"><small id="cols_min">1</small></div>
          <input id="cols" type="range" min="1" max="20" step="1"/>
          <div class="label"><small id="cols_max">20</small></div>
          <input class="options" id="cols_value"/> # Columns
          <br/>
        
          <div class="label"><small id="tiles_min">1</small></div>
          <input id="tiles" type="range" min="1" step="1"/>
          <div class="label"><small id="tiles_max"></small></div>
          <input class="options" id="tiles_value"/> # Most Different Tiles
          <br/>
        
          <div class="label"><small id="threshold_min">1</small></div>
          <input id="threshold" type="range" min="1" max="300" step="1"/>
          <div class="label"><small id="threshold_max">300</small></div>
          <input class="options" id="threshold_value"/> Scene Threshold
          <br/>
        
          <div class="label"><small id="boosting_min">1</small></div>
          <input id="boosting" type="range" min="1" max="2" step="0.1"/>
          <div class="label"><small id="boosting_max">2</small></div>
          <input class="options" id="boosting_value"/>
          Different Tile Boosting Factor
          <br/>
        
          <div class="label"><small id="limiting_min">0</small></div>
          <input id="limiting" type="range" min="0" max="1" step="0.1"/>
          <div class="label"><small id="limiting_max">1</small></div>
          <input class="options" id="limiting_value"/>
          Similar Tile Limiting Factor
          <br/>
        
          <input class="options" id="average"/> Frame Average Distance
          <br/>
        
          <input class="options" id="deviation"/> Frame Standard Deviation
          <br/>
        
          <input type="checkbox" id="keep_synced"/>
          <label for="keep_synced">
            Adjust Scene Threshold to Frame Standard Deviation
          </label>
        </div>
      </div>
    
      <div class="canvas" id="average_canvas"></div>
    
      <div class="progress" id="progress"></div>
    </div>
    <div class="scenes" id="scenes"></div>
    
    <script>
      (function () {        
        // global configuration object
        var GLOBAL_config = {
          normalTimeout: 100,
          debugTimeout: 500,
          normalCanvasWidth: 50,
          debugCanvasWidth: 300,
          videoHeight: 200,
          rows: 20,
          cols: 20,
          boosting: 2.0,
          limiting: 0.5,
          threshold: 50,
          proxy: 'http://tomayac.com/youpr0n/proxy.php?video=',
          step: 1,
          sortFunction: function (a, b) { return a - b; }
        };        
        
        // determine if we are embedded in a different webpage
        var embedded =
            window.parent.location.origin !== window.location.origin;        
        var embeddedOptions = document.querySelector('.embedded');
        // if we are embedded, do not show the options
        if (!embedded) {
          embeddedOptions.classList.toggle('embedded');            
        }
            
        // show similar tiles checkbox
        var similarCheckbox = document.getElementById('similar');
        var showSimilar = similarCheckbox.checked;
        similarCheckbox.addEventListener('change', function (e) {
          showSimilar = this.checked;
        }, false);
        
        // show different tiles checkbox
        var differentCheckbox = document.getElementById('different');
        var showDifferent = differentCheckbox.checked;
        differentCheckbox.addEventListener('change', function (e) {
          showDifferent = this.checked;
        }, false);
        
        // show debug mode checkbox
        var debugCheckbox = document.getElementById('debug');
        var debugOptions = document.getElementById('debug_options');
        var debug = debugCheckbox.checked;
        debugOptions.classList.toggle('debug_options');
        var timeout = null;
        var canvasWidth = null;
        if (!debug) {
          timeout = GLOBAL_config.normalTimeout;
          canvasWidth = GLOBAL_config.normalCanvasWidth;
        } else {
          timeout = GLOBAL_config.debugTimeout;
          canvasWidth = GLOBAL_config.debugCanvasWidth;
        }
        debugCheckbox.addEventListener('change', function () {
          debug = debugCheckbox.checked;
          debugOptions.classList.toggle('debug_options');
          if (!debug) {
            avgCanvas.parentNode.removeChild(avgCanvas);
            canvas.parentNode.removeChild(canvas);
            timeout = GLOBAL_config.normalTimeout;
            canvasWidth = GLOBAL_config.normalCanvasWidth;
          } else {
            averageCanvasDiv.appendChild(canvas);
            averageCanvasDiv.appendChild(avgCanvas);
            timeout = GLOBAL_config.debugTimeout;
            canvasWidth = GLOBAL_config.debugCanvasWidth;
          }
        }, false);
        
        // progress indicator for video analysis
        var videoProgress = document.createElement('progress');        
        var videoProgressContainer = document.querySelector('#progress');                
        // only show the video progress indicator if we are not embedded
        if (!embedded) {
          videoProgressContainer.appendChild(videoProgress);
        }
        videoProgress.max = 100;
        var videoProgressValue = 0; 
        videoProgress.value = videoProgressValue;
        
        // start button
        var videoIdInput = document.getElementById('video_id');
        var startButton = document.getElementById('start');
        startButton.addEventListener('click', function (e) {
          start(videoIdInput.value);
        }, false);                
        
        // main video element
        var video = document.createElement('video');
        video.controls = 'controls';
        var videoContainer = document.querySelector('DIV.video');
        // only show the video if we are not embedded
        if (!embedded) {
          videoContainer.appendChild(video);          
        }
        video.height = GLOBAL_config.videoHeight;
        
        // container for the two debug canvases
        var averageCanvasDiv = document.getElementById('average_canvas');
        
        // container for the video scenes
        var scenes = document.querySelector('#scenes');
        
        // rows slider
        var rowsSlider = document.getElementById('rows');
        var rowsValue = document.getElementById('rows_value');
        var rows = GLOBAL_config.rows;
        rowsValue.value = rows;
        rowsSlider.value = rows;
        rowsSlider.addEventListener('change', function (e) {
          rows = this.value;
          rows_x_cols = rows * cols;
          assureValidTiles();
          rowsValue.value = rows;
          rowsOrColsChanged = true;
        }, false);
        
        // average distance input
        var averageDistanceInput = document.getElementById('average');
        averageDistanceInput.value = 0;
        
        // standard devitation input
        var standardDeviationInput = document.getElementById('deviation');
        standardDeviationInput.value = 0;
        
        // adjust scene threshold to frame standard deviation checkbox
        var keepSyncedCheckbox = document.getElementById('keep_synced');
        var keepSynced = keepSyncedCheckbox.checked;
        keepSyncedCheckbox.addEventListener('change', function (e) {
          keepSynced = this.checked;
          if (keepSynced) {
            threshold = standardDeviationInput.value;
            if (thresholdSlider.value !== threshold) {
              thresholdSlider.value = threshold;
              thresholdValue.value = threshold;            
              updateScenes();
            }
          }
        }, false);
        
        // cols slider
        var colsSlider = document.getElementById('cols');
        var colsValue = document.getElementById('cols_value');
        var cols = GLOBAL_config.cols;
        colsValue.value = cols;
        colsSlider.value = cols;
        var rows_x_cols = rows * cols;
        var rowsOrColsChanged = false;
        colsSlider.addEventListener('change', function (e) {
          cols = this.value;
          rows_x_cols = rows * cols;
          assureValidTiles();
          colsValue.value = cols;
          rowsOrColsChanged = true;
        }, false);
        
        // threshold slider
        var thresholdSlider = document.getElementById('threshold');
        var thresholdValue = document.getElementById('threshold_value');
        var threshold = GLOBAL_config.threshold;
        thresholdValue.value = threshold;
        thresholdSlider.value = threshold;
        var distances = [];
        thresholdSlider.addEventListener('change', function (e) {
          if (threshold !== this.value) {
            threshold = this.value;
            thresholdValue.value = threshold;
            updateScenes();
          }
        }, false);
        
        // assures that the number of most similar / different tiles is never
        // greater than the number of absolute tiles
        function assureValidTiles() {
          tilesSlider.max = rows_x_cols;
          tilesMax.innerHTML = rows_x_cols;
          if (rows_x_cols < tiles) {
            tiles = rows_x_cols;
            tilesSlider.value = tiles;
            tilesValue.value = tiles;
          }
        }
        
        // rounds a double number to n decimals
        function round(num, numOfDec) {
          var pow10s = Math.pow(10, numOfDec || 0);
          return numOfDec ? Math.round(pow10s * num) / pow10s : num;
        }
        
        // different tiles boosting slider
        boostingSlider = document.getElementById('boosting');
        boostingValue = document.getElementById('boosting_value');
        var boosting = GLOBAL_config.boosting;
        boostingSlider.value = boosting;
        boostingValue.value = boosting;
        boostingSlider.addEventListener('change', function (e) {
          if (boosting !== this.value) {
            boosting = round(this.value, 1);
            boostingValue.value = boosting;
            updateScenes();
          }
        }, false);
        
        // similar tiles limiting slider
        limitingSlider = document.getElementById('limiting');
        limitingValue = document.getElementById('limiting_value');
        var limiting = GLOBAL_config.limiting;
        limitingSlider.value = limiting;
        limitingValue.value = limiting;
        limitingSlider.addEventListener('change', function (e) {
          if (limiting !== this.value) {
            limiting = round(this.value, 1);
            limitingValue.value = limiting;
            updateScenes();
          }
        }, false);
        
        // most similar / different tiles slider
        var tilesSlider = document.getElementById('tiles');
        var tilesValue = document.getElementById('tiles_value');
        var tilesMax = document.getElementById('tiles_max');
        var tiles = ~~(rows_x_cols / 3);
        tilesSlider.max = rows_x_cols;
        tilesMax.innerHTML = rows_x_cols;
        tilesSlider.value = tiles;
        tilesValue.value = tiles;
        tilesSlider.addEventListener('change', function (e) {
          tiles = this.value;
          tilesValue.value = tiles;
        }, false);
        
        // calculates the distance between two frames taking into account
        // the different tiles boosting factor and the similar tiles limiting
        // factor
        function calculateFrameDistance(thisFrame, lastFrame) {
          var abs = Math.abs;
          
          // first calculate the absolute distance form tile to tile
          // and store the results in a distance vector
          var absoluteDistance = [];
          for (var i = 0; i < rows_x_cols; i++) {
            absoluteDistance[i] = abs(thisFrame[i] - lastFrame[i]);
          }
          // copy the distance vector and sort it
          var absoluteDistanceCopy = absoluteDistance.slice(0);
          absoluteDistanceCopy.sort(GLOBAL_config.sortFunction);
          var mostSimilarTiles = [];
          var mostDifferentTiles = [];
          var index = null;
          // find the most similar and the most different tiles
          for (var i = 0; i < tiles; i++) {
            // find the most different tiles
            var maxDifference = absoluteDistanceCopy[rows_x_cols - i - 1];
            if (maxDifference > 0) {
              index = absoluteDistance.indexOf(maxDifference);
              mostDifferentTiles[i] = index;
              // x-out the already considered tiles
              absoluteDistance[index] = null;
            }
            // find the most similar tiles
            var minDifference = absoluteDistanceCopy[i];
            if (minDifference < maxDifference) {
              index = absoluteDistance.indexOf(minDifference);
              mostSimilarTiles[i] = index;
              // x-out the already considered tiles
              absoluteDistance[index] = null;
            }
          }
          // apply boosting / limiting factors to the most different / similar
          // tiles
          for (var i = 0; i < rows_x_cols; i++) {
            var value = thisFrame[i];
            var boostingFactor = 1;
            if (mostSimilarTiles.indexOf(i) !== -1) {
              boostingFactor = limiting;
            } else if (mostDifferentTiles.indexOf(i) !== -1) {
              boostingFactor = boosting;
            }
            thisFrame.average += value * boostingFactor;
          }
          // calculate the average with applied boosting / limiting factors
          thisFrame.average = ~~(thisFrame.average / rows_x_cols);
          // most different / similar tile data only
          var tileData = {
            mostDifferentTiles: mostDifferentTiles,
            mostSimilarTiles: mostSimilarTiles
          };
          // distance data only
          var distance = {
            absolute: abs(thisFrame.average - lastFrame.average),
            tiles: thisFrame
          }
          // return both distance data and tile data together
          return {
            distance: distance,
            tileData: tileData
          };
        }
        // main canvas element (displays frames from the main video element in
        // debug mode)
        var canvas = document.createElement('canvas');
        // average canvas element (displays average tiles and most similar /
        // different tiles in debug mode)
        var avgCanvas = document.createElement('canvas');
        if (debug) {          
          averageCanvasDiv.appendChild(canvas);
          averageCanvasDiv.appendChild(avgCanvas);
        }
        
        // updates the frame average distance and the frame standard deviation
        function updateSceneStats(average, standardDeviation) {
          averageDistanceInput.value = average;
          standardDeviationInput.value = standardDeviation;
          if (keepSynced) {
            thresholdSlider.value = standardDeviation;
            thresholdValue.value = standardDeviation;            
          }
        } 
        
        // updates the video scenes distribution upon changing either of: scene
        // threshold, different tile boosting factor, similar tile limiting
        // factor
        function updateScenes() {
          // recalculate distances with new limiting and boosting factors
          var newDistances = [];
          var thisFrame = distances[0].tiles;
          var lastFrame = thisFrame;
          var newDistance =
              (calculateFrameDistance(thisFrame, lastFrame)).distance;
          newDistances[0] = newDistance.absolute;
          for (var i = 1 /* yes, 1 */, len = distances.length; i < len; i++) {
            thisFrame = distances[i].tiles;
            lastFrame = distances[i - 1].tiles;
            newDistance =
                (calculateFrameDistance(thisFrame, lastFrame)).distance;
            newDistances[i] = newDistance.absolute;
          }
          // recalculate average distance, standard deviation distance
          var averageDistance = ~~Stat.getAverage(newDistances);
          var standardDeviationDistance =
              ~~Stat.getStandardDeviation(newDistances);
          updateSceneStats(averageDistance, standardDeviationDistance);
          // update scene distribution display
          var stripDivs = document.querySelectorAll('.strip');
          for (var i = 0, len = stripDivs.length; i < len; i++) {
            var div = stripDivs[i];
            div.classList.remove('break');
            var distance = newDistances[i];
            if (distance > threshold) {
              div.classList.add('break');
            }            
            div.getElementsByTagName('strong')[0].innerHTML = distance;
          }
        }        
        
        // main init / start function
        var interval = null;
        function start(id) {
          // removes all child nodes from an element
          function removeAllChildNodes(elem) {
            while(elem.hasChildNodes()){
              elem.removeChild(elem.lastChild);
            }
          }
          
          // formats the time in a readable way
          //
          // Core bits adapted (stolen) from
          // http://isithackday.com/videograbber/
          function formatTime(time) {
            var hours = parseInt((time / 60 / 60) % 60, 10);
            var mins = parseInt((time / 60) % 60, 10);
            var secs = parseInt(time, 10) % 60;
            var hourss = (hours < 10 ? '0' : '') + parseInt(hours, 10) + ':';
            var minss = (mins < 10 ? '0' : '') + parseInt(mins, 10) + ':';
            var secss  = (secs < 10 ? '0' : '') +(secs % 60);
            var timestring = ( hourss !== '00:' ? hourss : '' ) + minss + secss;
            return timestring;
          }
          // if an interval was active upon start-up, clear it          
          if (interval) {
            clearInterval(interval);
            interval = null;
          }
          // remove all child nodes from the video element and video scene
          // container
          removeAllChildNodes(video);          
          removeAllChildNodes(scenes);
          // copy the video (from youtube via id, or anywhere via url) to the
          // local domain (because of the same origin policy that applies to
          // canvas)
          $.ajax({
            dataType: 'json',
            url: GLOBAL_config.proxy + id,
            success: function (data) {
              if (!data) {
                throw 'Cannot Embed Video.';
              }
              for (var i = 0, len = data.length; i < len; i++) {
                var source = document.createElement('source');
                source.src = data[i].url;
                if (data[i].type) {
                  source.type = data[i].type
                }
                video.appendChild(source);
              }
              video.load();
            }
          });
          
          // on manual video play, remove the video scenes from the video scene
          // container
          video.addEventListener('play', function (e) {
            if (video.currentTime === 0) {
              removeAllChildNodes(scenes);
            }
          }, false);
          
          // upon load of all video metadata, configure the canvas dimensions
          // for the debug canvases
          video.addEventListener('loadedmetadata', function (e) {
            var max = Math.max;
            var min = Math.min;
            var videoWidth = video.videoWidth;
            var videoHeight = video.videoHeight;
            var videoRatio = videoWidth / videoHeight;
            video.volume = 0;
            var canvasHeight = ~~(canvasWidth / videoRatio);
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;            
            avgCanvas.width = canvasWidth;
            avgCanvas.height = canvasHeight;              
            var avgCtx = avgCanvas.getContext('2d');
            var ctx = canvas.getContext('2d');            
            
            // the first "last" frame does not exist
            var lastFrame = null;
            
            // upon load of the complete video data, start analyzing the video
            video.addEventListener('loadeddata', function (e) {
              analyzeVideo();
            }, false);
            
            // main video analysis function
            function analyzeVideo() {
              
              // draws the most similar / different tiles on the average canvas
              // when in debug mode
              function drawMostSimilarDifferentTiles(
                  mostDifferentTiles,
                  mostSimilarTiles) {
                var mod = null;
                var div = null;
                var dx = null;
                var dy = null;
                var dw2 = dw - 2;
                var dh2 = dh - 2;
                for (var i = 0; i < tiles; i++) {
                  // all most different tiles
                  if (showDifferent) {
                    var mostDifferentTile = mostDifferentTiles[i];
                    mod = (mostDifferentTile % cols);
                    div = ~~(mostDifferentTile / cols);
                    dx = mod * dw;
                    dy = div * dh;
                    avgCtx.strokeStyle = 'red';
                    avgCtx.strokeRect(dx + 1, dy + 1, dw2, dh2);
                  }
                  // all most similar tiles
                  if (showSimilar) {
                    var mostSimilarTile = mostSimilarTiles[i];
                    mod = (mostSimilarTile % cols);
                    div = ~~(mostSimilarTile / cols);
                    dx = mod * dw;
                    dy = div * dh;
                    avgCtx.strokeStyle = 'green';
                    avgCtx.strokeRect(dx + 1, dy + 1, dw2, dh2);
                  }
                }
              }
              
              // generates a video scene html snippet
              function generateSceneHtmlSnippet(currentTime, distance) {
                var time = parseFloat(currentTime);
                var src = canvas.toDataURL('image/png');
                var divCss = null;
                if (distance > threshold) {
                  divCss = 'class="break strip"';
                } else {
                  divCss = 'class="strip"';
                }
                html[counter] =
                    '<div ' + divCss + '><img src="' + src + '"/>' +
                    '<br/><small>' + formatTime(time) + ' / ' +
                    '<strong>' + distance +
                    '</strong></small></div>';
              }
              // analyze the video in n second steps
              var step = GLOBAL_config.step;
              // canvas and average canvas step widths / heights for the tiles
              var sw = ~~(videoWidth / cols);
              var sh = ~~(videoHeight / rows);
              var dw = ~~(canvasWidth / cols);
              var dh = ~~(canvasHeight / rows);
              // reset all variables before the main video analysis interval
              // starts
              video.currentTime = 0;
              var videoDuration = video.duration;              
              distances = [];
              var html = {};
              var counter = 0;
              // main video analysis interval, active while the video has not
              // been entirely analyzed
              interval = setInterval(function () {                
                // only recalculate canvas and average canvas step widths /
                // heights for the tiles when the tile layout has changed
                if (rowsOrColsChanged) {
                  sw = ~~(videoWidth / cols);
                  sh = ~~(videoHeight / rows);
                  dw = ~~(canvasWidth / cols);
                  dh = ~~(canvasHeight / rows);
                  rowsOrColsChanged = false;
                }
                // freeze the current time for the whole interval run-through
                var currentTime = video.currentTime;
                var percentage = ~~(currentTime / videoDuration * 100);                
                
                // update progress indicator
                if (percentage > videoProgressValue) {
                  // only send the message if we are embedded
                  if (embedded) {
                    window.parent.postMessage({progress: percentage},
                        'http://www.youtube.com');
                  }
                  videoProgress.value = percentage;
                  videoProgressValue = percentage;
                }
                
                // initialize this frame's object
                var thisFrame = {};
                // for all tiles
                for (var i = 0; i < rows_x_cols; i++) {
                  // calculate the boundaries for the current tile from the
                  // video and translate it to boundaries on the main canvas
                  var mod = (i % cols);
                  var div = ~~(i / cols);
                  var sx = mod * sw;
                  var sy = div * sh;
                  var dx = mod * dw;
                  var dy = div * dh;
                  // draw the current tile on the main canvas
                  ctx.drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh);
                  // calculate the histogram of the current tile
                  var histogram =
                      Histogram.getHistogram(ctx, dx, dy, dw, dh, false);
                  // when in debug mode, draw the current tile's average color
                  // on the average canvas
                  if (debug) {
                    avgCtx.fillStyle = histogram.css;
                    avgCtx.fillRect(dx, dy, dw, dh);
                  }
                  // store the current tile's average color value (weighted
                  // triple (r + g + b), see histogram.js)
                  thisFrame[i] = histogram.average;
                }
                // initialize this frame's overall average color value
                thisFrame.average = 0;
                // for the very first frame, the "last" frame is the current
                // frame
                if (!lastFrame) {
                  lastFrame = thisFrame;
                }
                // calculate the distance between this frame and the last frame
                var distanceData = calculateFrameDistance(thisFrame, lastFrame);
                var distance = distanceData.distance;
                distances.push(distance);
                // if in debug mode, draw the most different / similar tiles on
                // the average canvas.
                if (debug) {
                  drawMostSimilarDifferentTiles(
                      distanceData.tileData.mostDifferentTiles,
                      distanceData.tileData.mostSimilarTiles);
                }
                // the new last frame is the current this frame
                lastFrame = thisFrame;
                // generate the video scenes html snippet
                generateSceneHtmlSnippet(currentTime, distance.absolute);
                // prepare the next video step
                var nextTime = currentTime + step;
                // if the next step would be beyond the video's duration, clear
                // the interval and prepare the final video scene html
                if (nextTime >= videoDuration) {
                  clearInterval(interval);
                  videoProgress.value = 100;                  
                  // only send the message if we are embedded
                  if (embedded) {
                    window.parent.postMessage({progress: 100},
                        'http://www.youtube.com');                  
                  }
                  // seek the video back to the beginning
                  video.currentTime = 0;
                  // make sure the different video scene html snippets get
                  // displayed in the correct time order
                  var timestamps = Object.keys(html);
                  timestamps.sort(GLOBAL_config.sortFunction);
                  var innerHtml = '';
                  for (var i = 0, len = timestamps.length; i < len; i++) {
                    innerHtml += html[timestamps[i]];
                  }
                  scenes.innerHTML = innerHtml;
                  // recalculate average distance, standard deviation distance
                  var absoluteDistances = [];
                  for (var i = 0, len = distances.length; i < len; i++) {
                    absoluteDistances[i] = distances[i].absolute;
                  }
                  var average = ~~Stat.getAverage(absoluteDistances);
                  var standardDeviation =
                      ~~Stat.getStandardDeviation(absoluteDistances);                  
                  updateSceneStats(average, standardDeviation);
                // if the next video step is within the video's duration, seek
                // to the new position
                } else {
                  video.currentTime = nextTime;
                }
                // needed for the video scene html snippet time order
                counter++;
              }, timeout);
            }
          }, false);
        } 
        
        // automatically starts the analysis process if the script gets run 
        // remotely via an iframe
        (function init() {
          var videoId = window.location.getParameter('v');
          if (videoId) {            
            videoIdInput.value = videoId;            
            start(videoId);          
          }          
        })();        
               
      })();
    </script>
  </body>
</html>